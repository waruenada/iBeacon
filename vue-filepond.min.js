/*!
 * vue-filepond v7.0.2
 * A handy FilePond adapter component for Vue
 * 
 * Copyright (c) 2021 PQINA
 * https://pqina.nl/filepond
 * 
 * Licensed under the MIT license.
 */
!function(global,factory){if("function"==typeof define&&define.amd)define("vueFilePond",["exports","vue","filepond"],factory);else if("undefined"!=typeof exports)factory(exports,require("vue"),require("filepond"));else{var mod_exports={};factory(mod_exports,global.Vue,global.FilePond),global.vueFilePond=mod_exports}}("undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:this,function(_exports,_vue,_filepond){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.default=_exports.setOptions=void 0;
// Methods not made available to the component
var filteredComponentMethods=["setOptions","on","off","onOnce","appendTo","insertAfter","insertBefore","isAttachedTo","replaceElement","restoreElement","destroy"],isSupported=(0,_filepond.supported)(),props={},events=[],instances=[],globalOptions={};// Test if is supported on this client
_exports.setOptions=function(options){globalOptions=Object.assign(globalOptions,options),instances.forEach(function(instance){instance.setOptions(globalOptions)})};_exports.default=function(){for(var prop in
// register plugins in FilePond
_filepond.registerPlugin.apply(void 0,arguments),// build events and props array
events.length=0,_filepond.OptionTypes)
// don't add events to the props array
if(/^on/.test(prop))events.push(prop);else{// get property type ( can be either a String or the type defined within FilePond )
var valid_types=[String,(type=_filepond.OptionTypes[prop],{string:String,boolean:Boolean,array:Array,function:Function,int:Number,serverapi:Object,object:Object}[type])];// labelFileProcessingError can also be Function
"labelFileProcessingError"==prop&&valid_types.push(Function),props[prop]={type:valid_types,
// set this default value so we know which props have been explicitely set by user on component
default:"__unset__"}}// create
var type;return{name:"FilePond",props:props,render:function(){return(0,_vue.h)("div",{class:{"filepond--wrapper":!0}},[(0,_vue.h)("input",{id:this.id,name:this.name,type:"file",class:this.className,required:this.required,multiple:this.allowMultiple,accept:this.acceptedFileTypes,capture:this.captureMethod})])},created:function(){var _this=this;this.watchers=Object.keys(props).map(function(key){return _this.$watch(key,function(next){_this._pond[key]=next})})},
// Will setup FilePond instance when mounted
mounted:function(){var _this2=this;
// exit here if not supported
if(isSupported){// get pond element
this._element=this.$el.querySelector("input");// Map FilePond callback methods to Vue $emitters
var options=events.reduce(function(obj,value){return obj[value]=function(){_this2.$emit("input",_this2._pond?_this2._pond.getFiles():[]);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];_this2.$emit.apply(_this2,[value.substr(2)].concat(args))},obj},{}),passedProps={};Object.keys(props).forEach(function(key){"__unset__"!==_this2[key]&&(passedProps[key]=_this2[key])}),// Create our pond
this._pond=(0,_filepond.create)(this._element,Object.assign({},globalOptions,options,passedProps)),// Copy instance method references to component instance
Object.keys(this._pond).filter(function(key){return!filteredComponentMethods.includes(key)}).forEach(function(key){_this2[key]=_this2._pond[key]}),// Add to instances so we can apply global options when used
instances.push(this._pond)}},
// Will clean up FilePond instance when unmounted
beforeUnmount:function(){var _this3=this,detached=this.$options.detached;
// reference to detached method
// no longer attached, clean up
if(this.$el.offsetParent){new MutationObserver(function(mutations,observer){var removedNode=((mutations[0]||{}).removedNodes||[])[0];removedNode&&removedNode.contains(_this3.$el)&&(observer.disconnect(),detached.call(_this3))}).observe(document.documentElement,{childList:!0,subtree:!0})}// if we're still attached it's likely a transition is running, we need to
// determine the moment when we're no longer attached to the DOM so we can
// clean up properly
else detached.call(this)},
// called when the component root node has been detached
detached:function(){// exit when no pond defined
if(this.watchers.forEach(function(unwatch){return unwatch()}),this._pond){// bye bye pond
this._pond.destroy();// remove from instances
var index=instances.indexOf(this._pond);0<=index&&instances.splice(index,1),// clear reference
this._pond=null}}}}});